import sys
import time
import subprocess
from subprocess import Popen, PIPE, STDOUT
from collections import defaultdict

def parseData(chars):
   # chars format =  port number, name, os, date, rank, rankNum, modRank, des

   return (chars[0], chars[1], chars[2], chars[3], chars[4], int(chars[5]),
      float(chars[6]), chars[7])
      
def print_db(db):
   # prints exploit database contents
   
   for key in db:
      print key, len(db[key])
      for i in range(len(db[key])):
         print db[key][i]
         
def write_db_to_file(data):

   #TODO need to alter to accomdate writing later in program

   print "Saving exploit database to .db_exploits in CSV format"
   db_file = open(".db_exploits.txt", 'w')
   
   for line in data.splitlines():
      chars = line.split(',')
      (port, name, os, date, rank, rankNum, modRank, des) = parseData(chars)
         
      # writes exploit data to file
      
      dataString = str(port) + "," + str(name) + "," + str(os) + "," + str(date) + \
      "," + str(rank) + "," + str(rankNum) + "," + str(modRank) + "," + str(des)
   
      db_file.write(dataString)
      db_file.write("\n")
   
   db_file.close()

def read_db_from_file():

   print "Reading exploit database from .db_exploits.txt"
   db_file = open(".db_exploits.txt", 'r')
   data = db_file.readlines()
   db_file.close()

   return format_db(data)

def generate_db(exploit_file_gen):

   print "Generating exploit database"
   db = defaultdict()
   data = []

   p = subprocess.Popen(['java', '-jar', 'cortana.jar', 'connect.prop', 'exploits.cna'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)
   
   output = p.communicate()[0]
   if exploit_file_gen == 1:
      write_db_to_file(output)

   for line in output.splitlines():
      data.append(line)
         
   return format_db(data)

def format_db(in_data):

   db = defaultdict()

   for i in range(len(in_data)):
      chars = in_data[i].split(',')
      (port, name, os, date, rank, rankNum, modRank, des) = parseData(chars)

      # creates dictionary of information for each exploit
      data = {'name': name, 'os': os, 'rank': rank, 'rankNum': rankNum,
         'modRank': modRank, 'date': date, 'des': des}
      
      # creates a searchable database of exploits, organized by port number
      if port not in db:
         db[port] = []
      db[port].append(data)

   return db

def determine_db(exploit_file_gen):

   db = defaultdict()   
   db = generate_db(exploit_file_gen) if exploit_file_gen == 1 else read_db_from_file()
   return db
   
