import sys
import time
import shared
import subprocess
import nmap_scan
import atk_gen_db
import host_db_gen
import service_db_gen
import shared_util
from collections import defaultdict

def parseSessionData(sessions):

   session_db = defaultdict()

   for line in sessions.splitlines():
      chars = line.split(',')    #host, success?, sessionNum, user, exploit
      data = {'host': chars[0], 'success': chars[1], 'sessionNum': chars[2], \
        'user': chars[3], 'exploit': chars[4], 'type': chars[5]}

      session_db[chars[0]] = data

   return session_db

def checkIfTargetCompromised(session_db, target_ip):
   for session in session_db:
      if session['host'] == target_ip:
         return True
   return False

'''
def searchForTarget(session_db, target_ip, target_location, attacks, db_e, db_h, db_s):

   #privilege escaltion if needed, change shells to meterpreter sessions
   #creds = getHashes(session_db)
   session_db = manageSessions(session_db, db_h)


   {
         ## get hashdump from sessions, compile into credentials list
            ## windows = hashdump command
            ## linux = post/linux/gather/hashdump
         ## try to compromise targets in current level that don't have sessions

      # look for unspecified networks (graph-like structure)
         # windows = ipconfig | findstr /c:"IPv4 Address" /c:"Mask"
         # linux = ifconfig | grep 'inet addr' | cut -d: -f2 | awk '{print $1}'
         # linux = ifconfig | grep 'inet addr' | cut -d: -f4 | awk '{print $1}' 
      # repeat until no new networks are found
      # should be left with a graph-like structure
   } 

   targetCompromised = checkIfTargetCompromised(session_db, target_ip)
'''

'''
def getHashes(session_db):


'''

'''
def manageSessions(session_db, db_h):

   string = ""
   for session in session_db:
      if session['user'] != "root" or session['type'] != "meterpreter":
         string += session['sessionNum'] + "," + db_h[session['host']]['os_name'] + "," + session['host'] + ";"

   if string != "":
      string = string[:len(string) - 1]
   
      p = subprocess.Popen(['java', '-jar', 'cortana.jar', str(shared_util.prop_file_name), 'manageSessions.cna'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)

      print "Elevating privileges of sessions " + string         
      p.stdin.write("arguments %s" % string)
      output = p.communicate()[0]
      p.stdin.close();

      for line in output.splitlines():
         print line
         (sessionNum, privileges) = line.split(',')
         if session_db[sessionNum]['user'] != privileges:
            session_db[sessionNum]['user'] = privileges

   return session_db
'''
'''
use getsystem to elevate privileges for sessions that dont have root privileges
use 'ipconfig' or 'ifconfig' to look for unspecified networks, parse into dictionary
   use IPnetwork to transform subnets into integers (need ip address, mask)
   determine if target IP is within subnet for each compromised machine
   if yes:
      update routing table (autoroute)
      try to compromise with closest machine
      if yes:
         make note that target has been compromised
         store closest machine
         move one level backwards and try to exploit closest machine, continue until specified IPs are reached
      if no:
         look for same target subnet but different closest machine
   if no:
      continue to next available session
logging information:
   if target is found
   closest machine to target
   subnets that were found
   subnets that were explored
   routes to target from specified IPs
   if the target was compromised
   what machines are able to compromise the target
   what exploits are successful
'''
